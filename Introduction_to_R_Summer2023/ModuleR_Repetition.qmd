---
title: "Module R: Repetition"
author: "N. V. Schenk"
format: 
    html:
      toc: true
      self-contained: true
editor: source
execute: 
  cache: true
---

```{r}
#| label: requirements
#| include: false
# load and install necessary R packages
# This is not shown in the html script.

# install necessary R packages
if(!require(dplyr)) install.packages("tidyverse")
# if(!require(cowplot)) install.packages("cowplot")

# load necessary R packages
library(tidyverse)
```


# Repetition of Module 1

This document is the collection of exercises you have submitted while solving Module 1.


::: {.panel-tabset}

### Exercise

The operator `==` ("double-equal") checks if two elements (e.g. numbers) are the same.
```{r}
3 == 3 # by returning TRUE, R tells you that 3 is indeed the same as 3
3 == 4 # by returning FALSE, R tells you that 3 is NOT the same as 3
```

Create a vector a from 0 to 5 with step size 1. Create a second vector b from 0.1 to 0.3 with step size 0.1. Compare the lengths of vectors a and b, and check if the length is the same, by using the operator `==`


### Solution

```{r}
a <- seq(from = 0, to = 5, by = 1)
b <- seq(from = 0.1, to = 0.3, by = 0.1)

# checking the lengths of the two vectors by hand
length(a)
length(b)

# check if the length of vector a is the same as the length of vector b
length(a) == length(b)
# their lengths differ, because a is longer than b.
```

:::



::: {.panel-tabset}

### Exercise

The `>` operator tests if a given element (e.g. a number) is larger than another.

```{r}
3 > 1 # 3 is larger than 1
4 > 5 # 4 is NOT larger than 5
```

Use the operator `>` to check if vector a is longer than vector b.

### Solution

```{r}
length(a) > length(b)
```
Vector a is indeed longer than vector b.

**additionally**, you might have tried out this : 
```{r}
a > b
```
Here, the `>` operator is applied ELEMENTWISE, that means the first element of a is compared to the first element of b. In our case, 0 is compared to 0.1. 0 is not larger than 0.1, therefore the first answer is FALSE. Then, the second element of a is compared to the second element of b, i.e. 1 is compared to 0.2. 1 is larger than 0.2, therefore the second answer is TRUE. And so on.

*note* that again here, the vector b is "recycled", because it is not as long as a. That means, the fourth element of vector a is compared to the FIRST element of vector b.

:::



::: {.panel-tabset}

### Exercise

Create two sequences of numbers : The first is a sequence of numbers from 1 to 5, with steps of 1. Save this sequence in a variable called a. The second sequence is a sequence of numbers from 0.1 to 0.3, with steps of 0.1. Save this sequence in a variable called b. Subtract a from b.

### Solution

```{r}
a <- seq(from = 1, to = 5, by = 1)
b <- seq(from = 0.1, to = 0.3, by = 0.1)
sum <- b - a # R adjusts the length of b according the sequence of a and subtracts the values correspondingly from each sequence.
sum
```

:::


::: {.panel-tabset}

### Exercise

Create three sequences of numbers : The first is a sequence of numbers from 0 to 5, with steps of 1. Save this sequence in a variable called a. The second sequence is a sequence of numbers from 0 to 2.5, with steps of 0.5. Save this sequence in a variable called b. The third sequence is a sequence of numbers from 0 to 0.5, with steps of 0.1. Save this sequence in a variable called c.
Add a the sequences a and b, then divide by sequence c.


### Solution

```{r}
a <- seq(from = 0, to = 5, by = 1)
b <- seq(from = 0, to = 2.5, by = 0.5)
c <- seq(from = 0, to = 0.5, by = 0.1)
(a + b) / c
```
*note* that you get a `NaN`, the abbreviation for "not a number". This is the result of a division through zero, which is not defined. The first element of c is 0. 

:::


::: {.panel-tabset}

### Exercise

```{r}

```

### Solution

```{r}

```

:::


## Discussion insights

Insights discussed during the individual work or during the discussion sessions.

### R recycling

In module 1, a shorter vector was recycled to fit the length of a longer vector.
```{r}
a <- seq(from = 1, to = 5, by = 1)
b <- seq(from = 0.1, to = 0.3, by = 0.1)
a + b
```

This recycling of vectors is a particularity of R, if you need to search about it's behaviour, you can refer to it by "R's recycling rules". 

R's recycling rules dictate that if the recycled vector fits neatly into the longer vector without partial recycling, no warning is emitted.

That means if vector a was 6 elements long, vector b would fit percetly two times (no splitting of vector b), and you do not get a warning : 
```{r}
a <- seq(from = 1, to = 6, by = 1)
b <- seq(from = 0.1, to = 0.3, by = 0.1)
a + b
```


### overwriting vectors

By re-using a Vector's name, the former Vector is overwritten

### Run R code without click

Ctrl + Enter

Run multiple lines at once : select the lines you want to run, Ctrl + Enter


### Re-starting the graphics device

If plotting does not work any more, sometimes it helps to re-start the graphics device, using : 
```{r}
dev.off()
```
And trying to plot again.


# Module 2


# Module 3

# Module 4

# Outlook

## writing R output

After finishing an analysis or a plot, you certainly want to save some R output.

For plots, you can save via the RStudio Graphical User Interface (GUI) or via code.

### Saving plots via RStudio GUI

(1) Create your plot (2) click on "Export" on the top of the graphic panel. Save as image or as pdf. Note that you can select the output size. For PDF, select e.g. A5 landscape or A4, or the "device size" (the size your plot has on the graphic panel). For images, select the desired type, e.g. SVG for a vectorised image (which is not pixeled), or png for a pixel image. The with and height can be given manually as numbers, or manually be changing the preview size.
```{r}
library(ggplot2)
data(iris)
plot_iris <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point()
plot_iris
```

**Saving with code**

### Saving plots using the `ggplot2` package

Save **as png**
```{r, eval = F}
ggsave(plot_iris, 
       filename = "plot_iris_sepallength_sepalwidth.png",
       device = "png",
       width = 20, height = 20, units = "cm",
       dpi = 300)
```
Note that you can adjust the size of the image by setting width and height, e.g. in "cm". You can also chose inches "in" or pixels "px".

Further, you can set the image resolution in dpi (dots per inch). Often, journals require 300 dpi. Note that an image of 300 dpi quality takes up more memory than a usual R plot. The image quality suitable for showing on a screen is 72 dpi.


Save **as pdf**
```{r, eval = F}
ggsave(plot = plot_iris, 
       filename = "plot_iris_sepallength_sepalwidth.pdf",
       device = "pdf",
       width = 14.8, height = 21, units = "cm")
```
By using the with and height in cm arguments, you can e.g. write to an A5 format by specifying 14.8 cm width and 21 cm height which is the size of A5. Look up other paper formats if needed.


### Recommended : Saving plots using the `cowplot` package 

The `cowplot` package is a very useful plotting package. It not only allows you to print your plots easily to files, but it also helps you arranging then on a panel.
```{r}
# install.packages("cowplot")
library(cowplot)
```

Saving a plot as png, tiff or pdf
```{r, eval = F}
save_plot(plot = plot_iris,
          base_width = 14.8, base_height = 14.8, units = "cm",
          filename = "plot_iris_sepallength_sepalwidth.png",
          dpi = 72)

save_plot(plot = plot_iris,
          base_width = 14.8, base_height = 14.8, units = "cm",
          filename = "plot_iris_sepallength_sepalwidth.tiff",
          dpi = 72)

save_plot(plot = plot_iris,
          base_width = 14.8, base_height = 21, units = "cm",
          filename = "plot_iris_sepallength_sepalwidth.pdf")
```

#### various plots in one panel

Not only for saving is the `cowplot` package handy, but also to combine and label multiple plots on one panel. [This tutorial](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html) gives an introduction, here you get a first impression:
```{r}
hist_sepallength <- ggplot(iris, aes(x = Sepal.Length)) +
  geom_histogram() +
  theme_half_open() # note that some people prefer a white background

hist_sepalwidth <- ggplot(iris, aes(x = Sepal.Width)) +
  geom_histogram() +
  theme_half_open()

lineplot_iris <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point() +
  theme_half_open()
```
Gives you 3 individual plots.

Combine them on one panel by : 
```{r}
plot_grid(hist_sepallength, hist_sepalwidth, lineplot_iris,
          nrow = 2,
          labels = c("A", "B", "C"))
```

You can even combine plots which are already combined : 
```{r}
iris_histograms <- plot_grid(hist_sepallength, hist_sepalwidth,
          ncol = 2,
          labels = c("A", "B", "C"))
plot_grid(iris_histograms, lineplot_iris,
          nrow = 2,
          labels = c("", "C"))
```
As always, make sure you label the axes well with names and units (this is a bad example in this aspect).


### Writing datasets with Rbase (recommended)

```{r}
data(iris)
```

If you want to extract the iris dataset to a file on your computer, the functions look a bit similar than the reading functions. 

`write.csv` and `write.csv2` write csv files, either comma "," or semicolon ";" separated. These functions contains some unhandy default settings: We recommend specifying the `quote` argument to `FALSE`, to prevent quoting of all values in the output table. We also recommend setting the `row.names` argument to `FALSE`, to prevent printing a column of row numbers. Try out playing with those settings to find out exactly what they do. Remember to open the data files with your text editor to see exactly what happens. To just look at the values, you can open with Excel.
```{r, eval = F}
# comma-separated ","
write.csv(x = iris, file = "iris.csv",
          quote = F,
          row.names = F)  

# semicolon-separated ";"
write.csv2(x = iris, file = "iris.csv",
          quote = F,
          row.names = F)  
```


You can use the more generic `write.table` function, and set the separator yourself :
```{r, eval = F}
write.table(x = iris, file = "iris.csv",
            sep = ",",
            quote = F,
            row.names = F)
```
Using `sep = ","` writes a comma-separated file, using `sep = ";"` creates a semicolon-separated file. You can also use other separators, e.g. tab by setting `sep = "\t"`


#### Writing intermediate data

R has two internal data formats, which you can use : `.RData` and `.RDS`. Both of these file types are R-specific. While `.RDS` files are used to store single R objects, `.RData` files can save multiple objects. If you use those files a lot, you might want to read more about their differences. For now, I recommend using `.RDS` files because they ease a reproducible workflow (they can be assigned to a new names when reading in, see [D.4.1 Saving R Files in this book](https://rstudio-education.github.io/hopr/dataio.html)).

You can save a file using `saveRDS()` and read a .RDS file using `readRDS`.
```{r, eval = F}
saveRDS(object = iris, file = "iris.RDS")
rm(iris) # remove the iris object
iris <- readRDS("iris.RDS")
```
Note that .RDS files are not readable with Excel or Text editors, but only with R. Why should you then bother to create .RDS files? You might consider 2 reasons (amongst others) 

- (1) You can save the type of data in .RDS files, not just the values itself. If you save a tibble as .RDS, it is still a tibble when you read it in. If you save a matrix as .RDS file, it is still a matrix when you read it in.
- (2) Probably your R script generates different types of output. Some things, you might want to save for your manuscript. Other output might just be intermediate output, which is not in table format, as e.g. the output of many statistical modelling functions. You might want to save this output as a backup, and here .RDS files are useful. In this way, you can also clearly distinguish between intermediat output (.RDS) and "final output" (.csv and .pdf/.png).






